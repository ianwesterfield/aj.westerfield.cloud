"""
PowerShell validation and fixing utilities.

Provides syntax validation and auto-correction for PowerShell commands
commonly generated by LLMs.
"""

import re
import logging
from typing import List

logger = logging.getLogger("orchestrator.powershell")


class PowerShellValidator:
    """Validates and fixes PowerShell commands."""

    @staticmethod
    def validate_syntax(command: str) -> List[str]:
        """
        Validate PowerShell command syntax and return list of errors.
        Catches common LLM mistakes before they cause massive error output.
        """
        errors = []

        if command.startswith("powershell -Command") or command.startswith(
            "powershell -c"
        ):
            errors.append(
                "Unnecessary 'powershell -Command' wrapper - agent runs PowerShell directly"
            )

        single_quotes = command.count("'") - command.count("`'")
        double_quotes = command.count('"') - command.count('`"')

        if single_quotes % 2 != 0:
            errors.append("Missing closing single quote (') - unbalanced quotes")
        if double_quotes % 2 != 0:
            errors.append('Missing closing double quote (") - unbalanced quotes')

        if command.count("{") != command.count("}"):
            errors.append(
                f"Missing closing brace - {command.count('{')} open, {command.count('}')} close"
            )

        if command.count("(") != command.count(")"):
            errors.append(
                f"Missing closing parenthesis - {command.count('(')} open, {command.count(')')} close"
            )

        if "Where-Object" in command or "Where" in command:
            bad_where = re.search(r"\{\s*\.([A-Za-z]+)", command)
            if bad_where:
                errors.append(
                    f"Missing $_ before .{bad_where.group(1)} in Where-Object"
                )

        if re.search(r"Where-Object.*PSIsContainer.*\$false", command, re.IGNORECASE):
            errors.append("Use -File flag instead of Where-Object PSIsContainer filter")

        if "ForEach-Object" in command or "ForEach" in command:
            bad_foreach = re.search(r"\{\s*\.([A-Za-z]+)", command)
            if bad_foreach:
                errors.append(
                    f"Missing $_ before .{bad_foreach.group(1)} in ForEach-Object"
                )

        if (
            command.strip().lower().startswith("dir ")
            or command.strip().lower() == "dir"
        ):
            errors.append("Using cmd.exe 'dir' command - use Get-ChildItem instead")

        if "| |" in command:
            errors.append("Broken pipe syntax: '| |'")

        if re.search(r"-eq\s+Fal", command) and "$false" not in command.lower():
            errors.append("Use $false instead of False/Fal in comparisons")

        return errors

    @staticmethod
    def fix_command(command: str, errors: List[str]) -> str:
        """Attempt to fix PowerShell syntax errors."""
        fixed = command

        for error in errors:
            if "Unnecessary 'powershell -Command'" in error:
                wrapper_match = re.search(
                    r'powershell\s+(?:-Command|-c)\s+["\'](.+)["\']$',
                    fixed,
                    re.IGNORECASE | re.DOTALL,
                )
                if wrapper_match:
                    fixed = wrapper_match.group(1)
                    logger.info(f"GUARDRAIL: Removed powershell wrapper")

            if "Missing $_" in error:
                fixed = re.sub(r"\{\s*\.", "{$_.", fixed)

            if "Use -File flag instead" in error:
                fixed = re.sub(
                    r"\|\s*Where-Object\s*\{[^}]*PSIsContainer[^}]*\}",
                    "",
                    fixed,
                    flags=re.IGNORECASE,
                )
                if "-File" not in fixed and "Get-ChildItem" in fixed:
                    fixed = re.sub(r"(Get-ChildItem\s+)", r"\1-File ", fixed)

            if "cmd.exe 'dir'" in error:
                path_match = re.search(
                    r"dir\s+(?:/[a-z-]+\s+)*([A-Z]:[\\]?[^\s/]*)", fixed, re.IGNORECASE
                )
                recurse_flag = "/s" in fixed.lower()
                path = path_match.group(1) if path_match else "C:\\"
                if path.endswith(":"):
                    path = path + "\\"
                recurse = "-Recurse" if recurse_flag else ""
                fixed = f"Get-ChildItem -Path {path} {recurse}".strip()

            if "$false instead of False" in error:
                fixed = re.sub(r"-eq\s+False", "-eq $false", fixed, flags=re.IGNORECASE)
                fixed = re.sub(
                    r"-eq\s+Fal\w*", "-eq $false", fixed, flags=re.IGNORECASE
                )

        if (
            "Get-ChildItem" in fixed
            and "-Recurse" in fixed
            and "-ErrorAction" not in fixed
        ):
            fixed = re.sub(
                r"(Get-ChildItem[^|]*-Recurse[^|]*?)(\s*\||$)",
                r"\1 -ErrorAction SilentlyContinue\2",
                fixed,
            )

        return fixed


class ScriptValidator:
    """Validates scripts in various languages."""

    def validate(self, script: str, language: str = "powershell") -> dict:
        """Validate a script for syntax, logic, and safety issues."""
        issues = []
        language = language.lower()

        if language == "powershell":
            issues = self._validate_powershell(script)
        elif language == "python":
            issues = self._validate_python(script)
        elif language in ("bash", "shell", "sh"):
            issues = self._validate_bash(script)
        else:
            issues = self._validate_generic(script)

        errors = [i for i in issues if i.get("severity") == "error"]
        warnings = [i for i in issues if i.get("severity") == "warning"]
        fixable_types = {"syntax", "missing_error_handling", "missing_quoting"}
        can_fix = all(i.get("type") in fixable_types for i in errors)
        fixed_script = (
            self._fix_script(script, errors, language) if can_fix and errors else None
        )

        if not issues:
            summary = "✅ Script looks good - no syntax or safety issues detected"
        elif can_fix:
            summary = f"⚠️ Found {len(errors)} fixable issue(s). Can auto-correct."
        else:
            summary = f"❌ Found {len(errors)} issue(s) needing review + {len(warnings)} warning(s)"

        return {
            "valid": len(errors) == 0,
            "issues": issues,
            "errors": errors,
            "warnings": warnings,
            "summary": summary,
            "can_fix": can_fix,
            "fixed_script": fixed_script,
            "language": language,
        }

    def _validate_powershell(self, script: str) -> list:
        issues = []
        quote_issues = self._check_unmatched_quotes(script)
        for line_num, quote_char in quote_issues:
            issues.append(
                {
                    "type": "syntax",
                    "severity": "error",
                    "description": f"Missing closing {quote_char}",
                    "line": line_num,
                    "suggestion": f"Check line {line_num}",
                }
            )

        brace_issues = self._check_unmatched_braces(script)
        for line_num, pair in brace_issues:
            issues.append(
                {
                    "type": "syntax",
                    "severity": "error",
                    "description": f"Unmatched {pair[0]}...{pair[1]}",
                    "line": line_num,
                    "suggestion": f"Check line {line_num}",
                }
            )

        if re.search(r"Where-Object|Where\s+\{|ForEach-Object|ForEach\s+\{", script):
            if re.search(r"\{\s*\.([A-Za-z])", script):
                issues.append(
                    {
                        "type": "syntax",
                        "severity": "error",
                        "description": "Missing $_ before property in script block",
                        "line": None,
                        "suggestion": "Use $_.PropertyName",
                    }
                )

        if (
            "Get-ChildItem" in script
            and "-Recurse" in script
            and "-ErrorAction" not in script
        ):
            issues.append(
                {
                    "type": "missing_error_handling",
                    "severity": "warning",
                    "description": "Get-ChildItem -Recurse without -ErrorAction handling",
                    "line": None,
                    "suggestion": "Add -ErrorAction SilentlyContinue",
                }
            )

        dangerous = [
            (r"Remove-Item\s+.*-Recurse", "Recursive delete without confirmation"),
            (r"Format-Volume", "Disk format operation without confirmation"),
        ]
        for pattern, desc in dangerous:
            if re.search(pattern, script, re.IGNORECASE):
                issues.append(
                    {
                        "type": "safety",
                        "severity": "error",
                        "description": desc,
                        "line": None,
                        "suggestion": "Requires explicit user confirmation",
                    }
                )
        return issues

    def _validate_python(self, script: str) -> list:
        issues = []
        try:
            import ast

            ast.parse(script)
        except SyntaxError as e:
            issues.append(
                {
                    "type": "syntax",
                    "severity": "error",
                    "description": f"Syntax error: {e.msg}",
                    "line": e.lineno,
                    "suggestion": f"Check line {e.lineno}: {e.text.strip() if e.text else ''}",
                }
            )

        if "open(" in script and "except" not in script:
            issues.append(
                {
                    "type": "missing_error_handling",
                    "severity": "warning",
                    "description": "File operations without error handling",
                    "line": None,
                    "suggestion": "Add try/except",
                }
            )
        return issues

    def _validate_bash(self, script: str) -> list:
        issues = []
        if not script.startswith("#!/"):
            issues.append(
                {
                    "type": "logic",
                    "severity": "warning",
                    "description": "No shebang line",
                    "line": 1,
                    "suggestion": "Start with #!/bin/bash",
                }
            )

        quote_issues = self._check_unmatched_quotes(script)
        for line_num, quote_char in quote_issues:
            issues.append(
                {
                    "type": "syntax",
                    "severity": "error",
                    "description": f"Missing closing {quote_char}",
                    "line": line_num,
                    "suggestion": f"Check line {line_num}",
                }
            )

        if re.search(r"rm\s+-\w*r\w*f", script) and not re.search(
            r"rm\s+-\w*i", script
        ):
            issues.append(
                {
                    "type": "safety",
                    "severity": "error",
                    "description": "rm -rf without confirmation",
                    "line": None,
                    "suggestion": "Requires explicit user confirmation",
                }
            )
        return issues

    def _validate_generic(self, script: str) -> list:
        issues = []
        quote_issues = self._check_unmatched_quotes(script)
        for line_num, quote_char in quote_issues:
            issues.append(
                {
                    "type": "syntax",
                    "severity": "error",
                    "description": f"Possible unmatched {quote_char}",
                    "line": line_num,
                    "suggestion": f"Check line {line_num}",
                }
            )
        return issues

    def _check_unmatched_quotes(self, text: str) -> list:
        issues = []
        for line_num, line in enumerate(text.split("\n"), 1):
            if line.strip().startswith("#"):
                continue
            dq, sq, in_str, esc = 0, 0, False, False
            for c in line:
                if esc:
                    esc = False
                    continue
                if c == "\\":
                    esc = True
                    continue
                if c == '"' and not in_str:
                    dq += 1
                    in_str = True
                elif c == '"' and in_str:
                    dq = max(0, dq - 1)
                    in_str = False
                if c == "'" and not in_str:
                    sq += 1
                    in_str = True
                elif c == "'" and in_str:
                    sq = max(0, sq - 1)
                    in_str = False
            if dq > 0:
                issues.append((line_num, '"'))
            if sq > 0:
                issues.append((line_num, "'"))
        return issues

    def _check_unmatched_braces(self, text: str) -> list:
        issues = []
        stack = []
        pairs = {"{": "}", "[": "]", "(": ")"}
        for line_num, line in enumerate(text.split("\n"), 1):
            if line.strip().startswith("#"):
                continue
            for c in line:
                if c in pairs:
                    stack.append((c, line_num))
                elif c in pairs.values():
                    if not stack:
                        issues.append((line_num, ("?", c)))
                    else:
                        o, ol = stack[-1]
                        if pairs[o] == c:
                            stack.pop()
                        else:
                            issues.append((line_num, (o, c)))
        for c, ln in stack:
            issues.append((ln, (c, pairs[c])))
        return issues

    def _fix_script(self, script: str, errors: list, language: str) -> str:
        fixed = script
        if language == "powershell":
            for error in errors:
                if error.get("type") == "missing_error_handling":
                    if "Get-ChildItem" in fixed and "-ErrorAction" not in fixed:
                        fixed = re.sub(
                            r"(Get-ChildItem\s+[^|]*?)(\s*\|)",
                            r"\1 -ErrorAction SilentlyContinue\2",
                            fixed,
                        )
        return fixed
